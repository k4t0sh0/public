<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>Mind Map</title>

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: sans-serif;
        }

        #app {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: white;
        }

        /* パネル共通 */
        .panel {
            position: absolute;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, .1);
            padding: 8px;
            z-index: 20;
        }

        button {
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            color: white;
            font-size: 13px;
        }

        svg {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        /* Finder全画面 */
        #finderOverlay {
            position: fixed;
            inset: 0;
            background: #f9fafb;
            z-index: 100;
            transform: translateX(100%);
            transition: transform .3s ease;
            display: flex;
            flex-direction: column;
        }

        /* 表示中 */
        #finderOverlay.show {
            transform: translateX(0);
        }

        /* ヘッダー */
        #finderHeader {
            height: 48px;
            background: white;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 12px;
            font-weight: bold;
        }

        /* カラム本体 */
        #columns {
            flex: 1;
            overflow-x: auto;
            white-space: nowrap;
        }

        /* カラムボタン */
        #finderBtn {
            position: absolute;
            bottom: 24px;
            right: 24px;
            z-index: 30;
            background: #334155;
            color: white;
            border-radius: 999px;
            padding: 10px 16px;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <div id="app">

        <!-- 右上ズーム -->
        <div class="panel" style="top:16px;right:16px;display:flex;gap:4px">
            <button style="background:#64748b" onclick="zoomIn()">＋</button>
            <button style="background:#64748b" onclick="zoomOut()">－</button>
            <button style="background:#64748b" onclick="resetView()">⟳</button>
        </div>

        <!-- SVG -->
        <svg id="svg">
            <defs>
                <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                    <circle cx="1" cy="1" r="1" fill="#e5e7eb" />
                </pattern>
            </defs>
            <rect width="100%" height="100%" fill="url(#grid)" />
            <g id="view"></g>
        </svg>

        <!-- パンくず -->
        <div id="breadcrumb" class="panel" style="top:80px;left:16px;display:none"></div>

        <!-- 下部操作 -->
        <div id="actions" class="panel" style="bottom:24px;left:50%;transform:translateX(-50%);
         display:none;gap:8px">
            <button style="background:#6366f1" onclick="addChild()">追加</button>
            <button style="background:#10b981" onclick="startEdit()">編集</button>
            <button id="deleteBtn" style="background:#ef4444" onclick="deleteNode()">削除</button>
        </div>

        <!-- Finder 全画面カラム -->
        <div id="finderOverlay">
            <div id="finderHeader">
                <span>ノード一覧</span>
                <button onclick="toggleFinder()">×</button>
            </div>
            <div id="columns"></div>
        </div>

        <!-- Finder表示ボタン -->
        <button id="finderBtn" onclick="toggleFinder()">一覧</button>


    </div>

    <script>
        /* ===== 状態 ===== */
        const colors = ['#6366f1', '#22c55e', '#ef4444', '#f59e0b', '#06b6d4'];

        let nodes = [{
            id: 1,
            text: 'メインアイデア',
            x: 400,
            y: 300,
            parentId: null,
            color: '#6366f1',
            isRoot: true
        }];

        let nextId = 2;
        let selectedNode = null;
        let draggingNode = null;
        let dragOffset = { x: 0, y: 0 };
        let viewOffset = { x: 0, y: 0 };
        let zoom = 1;
        let draggingCanvas = false;
        let dragStart = { x: 0, y: 0 };
        let editingNode = null;

        let finderSelectedNode = null;


        const svg = document.getElementById('svg');
        const view = document.getElementById('view');
        const actions = document.getElementById('actions');
        const deleteBtn = document.getElementById('deleteBtn');
        const breadcrumb = document.getElementById('breadcrumb');

        /* ===== 描画 ===== */
        function draw() {
            view.innerHTML = '';

            // 接続線
            nodes.forEach(n => {
                if (!n.parentId) return;
                const p = nodes.find(x => x.id === n.parentId);
                if (!p) return;

                const isRight = n.x > p.x;
                const sp = p.isRoot ? 70 : 10;
                const ep = n.isRoot ? 70 : 10;

                const sx = isRight ? p.x + sp : p.x - sp;
                const ex = isRight ? n.x - ep : n.x + ep;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d',
                    `M ${sx} ${p.y}
       C ${(sx + ex) / 2} ${p.y},
         ${(sx + ex) / 2} ${n.y},
         ${ex} ${n.y}`
                );
                path.setAttribute('stroke', '#cbd5e1');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('fill', 'none');
                view.appendChild(path);
            });

            nodes.forEach(n => {
                if (n.isRoot) drawRoot(n);
                else drawNode(n);
            });

            view.setAttribute(
                'transform',
                `translate(${viewOffset.x},${viewOffset.y}) scale(${zoom})`
            );
        }

        /* ===== ノード描画 ===== */
        function drawRoot(n) {
            const e = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
            e.setAttribute('cx', n.x);
            e.setAttribute('cy', n.y);
            e.setAttribute('rx', 70);
            e.setAttribute('ry', 45);
            e.setAttribute('fill', n.color);
            e.setAttribute('stroke', selectedNode === n.id ? '#1e293b' : 'white');
            e.setAttribute('stroke-width', selectedNode === n.id ? 3 : 2);
            e.onmousedown = ev => startNodeDrag(ev, n);
            view.appendChild(e);
            drawText(n, 'white', true);
        }

        function drawNode(n) {
            const r = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            r.setAttribute('x', n.x - 70);
            r.setAttribute('y', n.y - 30);
            r.setAttribute('width', 140);
            r.setAttribute('height', 60);
            r.setAttribute('rx', 8);
            r.setAttribute('fill', 'white');
            r.setAttribute('stroke', n.color);
            r.setAttribute('stroke-width', 2);
            r.onmousedown = ev => startNodeDrag(ev, n);
            view.appendChild(r);
            drawText(n, n.color, false);
        }

        function drawText(n, color, bold) {
            const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            t.setAttribute('x', n.x);
            t.setAttribute('y', n.y);
            t.setAttribute('text-anchor', 'middle');
            t.setAttribute('dominant-baseline', 'middle');
            t.setAttribute('fill', color);
            t.style.fontWeight = bold ? 'bold' : 'normal';
            t.textContent = n.text;
            view.appendChild(t);
        }

        /* ===== 選択 ===== */
        function selectNode(id) {
            selectedNode = id;
            actions.style.display = 'flex';
            deleteBtn.style.display = id === 1 ? 'none' : 'inline-block';
            updateBreadcrumb();
            updateColumns();   // ← 追加
            draw();
        }


        function saveData() {
            localStorage.setItem('mindmap-nodes', JSON.stringify(nodes));
        }

        function loadData() {
            const data = localStorage.getItem('mindmap-nodes');
            if (!data) return;

            try {
                nodes = JSON.parse(data);

                // 次のIDを復元（重要）
                nextId = Math.max(...nodes.map(n => n.id)) + 1;
            } catch {
                // 壊れていたら何もしない
            }
        }

        /* ===== パンくず ===== */
        function updateBreadcrumb() {
            breadcrumb.innerHTML = '';
            breadcrumb.style.display = 'block';

            let list = [];
            let cur = nodes.find(n => n.id === selectedNode);
            while (cur) {
                list.unshift(cur);
                cur = cur.parentId ? nodes.find(n => n.id === cur.parentId) : null;
            }

            list.forEach((n, i) => {
                const span = document.createElement('span');
                span.textContent = n.text.length > 15 ? n.text.slice(0, 15) + '…' : n.text;
                span.style.cursor = 'pointer';
                span.onclick = () => selectNode(n.id);
                breadcrumb.appendChild(span);
                if (i < list.length - 1) {
                    breadcrumb.appendChild(document.createTextNode(' › '));
                }
            });
        }

        /* ===== Finderカラム =====*/
        function getPath(nodeId) {
            const path = [];
            let cur = nodes.find(n => n.id === nodeId);
            while (cur) {
                path.unshift(cur);
                cur = cur.parentId ? nodes.find(n => n.id === cur.parentId) : null;
            }
            return path;
        }

        const columns = document.getElementById('columns');
        function updateColumns() {
            columns.innerHTML = '';

            if (!finderSelectedNode && !selectedNode) return;

            const baseNodeId = finderSelectedNode ?? selectedNode;
            const path = getPath(baseNodeId);

            // ★ 1つ先の階層まで描画するため +1
            for (let depth = 0; depth <= path.length; depth++) {
                const col = document.createElement('div');
                col.style.display = 'inline-block';
                col.style.verticalAlign = 'top';
                col.style.width = '220px';
                col.style.height = '100%';
                col.style.borderRight = '1px solid #e5e7eb';
                col.style.padding = '6px';
                col.style.boxSizing = 'border-box';

                let parentId;
                let highlightId = null;

                if (depth === 0) {
                    parentId = null;              // ルート一覧
                    highlightId = path[0]?.id;
                } else if (depth < path.length) {
                    parentId = path[depth - 1].id; // 通常の兄弟
                    highlightId = path[depth]?.id;
                } else {
                    // ★ 最後：選択ノードの子一覧
                    parentId = path[path.length - 1].id;
                    highlightId = null;
                }

                const list = nodes.filter(n => n.parentId === parentId);

                // 空でもカラムは表示（Finderと同じ）
                if (list.length === 0) {
                    const empty = document.createElement('div');
                    empty.textContent = '（子ノードなし）';
                    empty.style.color = '#9ca3af';
                    empty.style.fontSize = '13px';
                    empty.style.padding = '6px';
                    col.appendChild(empty);
                }

                list.forEach(n => {
                    const item = document.createElement('div');
                    item.textContent = n.text;
                    item.style.padding = '6px 8px';
                    item.style.marginBottom = '4px';
                    item.style.borderRadius = '6px';
                    item.style.cursor = 'pointer';
                    item.style.background =
                        n.id === highlightId || n.id === finderSelectedNode
                            ? '#c7d2fe'
                            : 'transparent';

                    item.onclick = (e) => {
                        e.stopPropagation();
                        finderSelectedNode = n.id;
                        updateColumns();
                    };

                    col.appendChild(item);
                });

                columns.appendChild(col);
            }
        }




        /* ===== ドラッグ ===== */
        function startNodeDrag(e, n) {
            e.stopPropagation();
            draggingNode = n;
            dragOffset = { x: e.offsetX / zoom - n.x, y: e.offsetY / zoom - n.y };
            selectNode(n.id);
        }

        svg.onmousedown = e => {
            draggingCanvas = true;
            dragStart = { x: e.clientX - viewOffset.x, y: e.clientY - viewOffset.y };
        };

        window.onmousemove = e => {
            if (draggingNode) {
                draggingNode.x = e.offsetX / zoom - dragOffset.x;
                draggingNode.y = e.offsetY / zoom - dragOffset.y;
                draw();
            } else if (draggingCanvas) {
                viewOffset.x = e.clientX - dragStart.x;
                viewOffset.y = e.clientY - dragStart.y;
                draw();
            }
        };

        window.onmouseup = () => {
            if (draggingNode) {
                saveData();
            }
            draggingNode = null;
            draggingCanvas = false;
        };


        /* ===== 操作 ===== */
        function addChild() {
            const p = nodes.find(n => n.id === selectedNode);
            if (!p) return;
            const angle = Math.random() * Math.PI * 2;
            const d = 200;
            nodes.push({
                id: nextId++,
                text: '新しいノード',
                x: p.x + Math.cos(angle) * d,
                y: p.y + Math.sin(angle) * d,
                parentId: p.id,
                color: colors[Math.floor(Math.random() * colors.length)],
                isRoot: false
            });

            draw();
            saveData();
        }

        function startEdit() {
            const n = nodes.find(n => n.id === selectedNode);
            if (!n) return;
            const t = prompt('編集', n.text);
            if (t !== null) {
                n.text = t;
                draw();
                updateBreadcrumb();
            }
            saveData();
        }

        function deleteNode() {
            function remove(id) {
                nodes.filter(n => n.parentId === id).forEach(c => remove(c.id));
                nodes = nodes.filter(n => n.id !== id);
            }
            if (selectedNode !== 1) {
                remove(selectedNode);
                selectedNode = null;
                actions.style.display = 'none';
                breadcrumb.style.display = 'none';
                draw();
            }
            saveData();
        }

        /* ===== ズーム ===== */
        function zoomIn() { zoom = Math.min(zoom * 1.2, 3); draw(); }
        function zoomOut() { zoom = Math.max(zoom * 0.8, 0.3); draw(); }
        function resetView() { zoom = 1; viewOffset = { x: 0, y: 0 }; draw(); }

        loadData();
        selectedNode = 1;
        draw();


        const finderOverlay = document.getElementById('finderOverlay');

        function toggleFinder() {
            finderOverlay.classList.toggle('show');

            if (finderOverlay.classList.contains('show')) {
                finderSelectedNode = selectedNode; // 今の位置から開始
                updateColumns();
            }
        }


        window.addEventListener('keydown', e => {
            if (e.key === 'Escape' && finderOverlay.classList.contains('show')) {
                toggleFinder();
            }
        });

        window.addEventListener('keydown', (e) => {
            if (e.key !== 'Enter') return;

            // Finderが開いていないなら無視
            if (!finderOverlay.classList.contains('show')) return;

            // 選択されていなければ無視
            if (!finderSelectedNode) return;

            // ① マップ側の選択を確定
            selectNode(finderSelectedNode);

            // ② テレポート
            const node = nodes.find(n => n.id === finderSelectedNode);
            if (node) teleportToNode(node);

            // ③ Finderを閉じる
            toggleFinder();
        });

        function teleportToNode(node) {
            const cx = window.innerWidth / 2;
            const cy = window.innerHeight / 2;

            viewOffset.x = cx - node.x * zoom;
            viewOffset.y = cy - node.y * zoom;

            draw();
        }


    </script>
</body>

</html>
