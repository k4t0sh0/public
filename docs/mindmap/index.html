<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mind Map</title>

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        #app {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: white;
        }

        .panel {
            position: absolute;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, .1);
            padding: 8px;
            z-index: 20;
        }

        button {
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            color: white;
            font-size: 13px;
            font-weight: 500;
        }

        button:hover {
            opacity: 0.9;
        }

        svg {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        svg:active {
            cursor: grabbing;
        }

        #finderOverlay {
            position: fixed;
            inset: 0;
            background: #f9fafb;
            z-index: 100;
            transform: translateX(100%);
            transition: transform .3s ease;
            display: flex;
            flex-direction: column;
        }

        #finderOverlay.show {
            transform: translateX(0);
        }

        #finderHeader {
            height: 48px;
            background: white;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 12px;
            font-weight: bold;
        }

        #columns {
            flex: 1;
            overflow-x: auto;
            white-space: nowrap;
        }

        #finderBtn {
            position: absolute;
            bottom: 24px;
            right: 24px;
            z-index: 30;
            background: #334155;
            color: white;
            border-radius: 999px;
            padding: 10px 16px;
            font-size: 14px;
        }

        .breadcrumb-item {
            display: inline;
            color: #4b5563;
            cursor: pointer;
        }

        .breadcrumb-item:hover {
            color: #1f2937;
        }

        .column-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 14px;
        }

        .column-item:hover {
            background: #f3f4f6;
        }

        .column-item.selected {
            background: #c7d2fe;
        }
    </style>
</head>

<body>
    <div id="app">

        <!-- 右上ズーム -->
        <div class="panel" style="top:16px;right:16px;display:flex;gap:4px">
            <button style="background:#64748b" onclick="zoomIn()">+</button>
            <button style="background:#64748b" onclick="zoomOut()">−</button>
            <button style="background:#64748b" onclick="resetView()">⟳</button>
            <button style="background:#3b82f6" onclick="exportData()">↓</button>
            <button style="background:#10b981" onclick="document.getElementById('importFile').click()">↑</button>
        </div>

        <input type="file" id="importFile" accept=".json" style="display:none" onchange="importData(event)">

        <!-- SVG -->
        <svg id="svg">
            <defs>
                <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                    <circle cx="1" cy="1" r="1" fill="#e5e7eb" />
                </pattern>
            </defs>
            <rect width="100%" height="100%" fill="url(#grid)" />
            <g id="view"></g>
        </svg>

        <!-- パンくず -->
        <div id="breadcrumb" class="panel" style="top:80px;left:16px;display:none"></div>

        <!-- 下部操作 -->
        <div id="actions" class="panel" style="bottom:24px;left:50%;transform:translateX(-50%);
         display:none;gap:8px">
            <button style="background:#6366f1" onclick="addChild()">追加</button>
            <button style="background:#10b981" onclick="startEdit()">編集</button>
            <button id="deleteBtn" style="background:#ef4444" onclick="deleteNode()">削除</button>
        </div>

        <!-- Finder 全画面カラム -->
        <div id="finderOverlay">
            <div id="finderHeader">
                <span>ノード一覧</span>
                <button onclick="toggleFinder()" style="background:#64748b">×</button>
            </div>
            <div id="columns"></div>
        </div>

        <!-- Finder表示ボタン -->
        <button id="finderBtn" onclick="toggleFinder()">一覧</button>

    </div>

    <script>
        const colors = ['#6366f1', '#22c55e', '#ef4444', '#f59e0b', '#06b6d4'];

        let nodes = [{
            id: 1,
            text: 'メインアイデア',
            x: 400,
            y: 300,
            parentId: null,
            color: '#6366f1',
            isRoot: true
        }];

        let nextId = 2;
        let selectedNode = null;
        let draggingNode = null;
        let dragOffset = { x: 0, y: 0 };
        let viewOffset = { x: 0, y: 0 };
        let zoom = 1;
        let draggingCanvas = false;
        let dragStart = { x: 0, y: 0 };
        let finderSelectedNode = null;

        const svg = document.getElementById('svg');
        const view = document.getElementById('view');
        const actions = document.getElementById('actions');
        const deleteBtn = document.getElementById('deleteBtn');
        const breadcrumb = document.getElementById('breadcrumb');

        function wrapText(text, maxChars) {
            const lines = [];
            let currentLine = '';

            for (let i = 0; i < text.length; i++) {
                if (currentLine.length >= maxChars) {
                    lines.push(currentLine);
                    currentLine = text[i];
                } else {
                    currentLine += text[i];
                }
            }

            if (currentLine.length > 0) {
                lines.push(currentLine);
            }

            return lines.length > 0 ? lines : [''];
        }

        function draw() {
            view.innerHTML = '';

            // 接続線
            nodes.forEach(n => {
                if (!n.parentId) return;
                const p = nodes.find(x => x.id === n.parentId);
                if (!p) return;

                const isRight = n.x > p.x;
                const sp = p.isRoot ? 70 : 70;
                const ep = n.isRoot ? 70 : 70;

                const sx = isRight ? p.x + sp : p.x - sp;
                const ex = isRight ? n.x - ep : n.x + ep;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d',
                    `M ${sx} ${p.y}
                     C ${(sx + ex) / 2} ${p.y},
                       ${(sx + ex) / 2} ${n.y},
                       ${ex} ${n.y}`
                );
                path.setAttribute('stroke', '#cbd5e1');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('fill', 'none');
                view.appendChild(path);
            });

            nodes.forEach(n => {
                if (n.isRoot) drawRoot(n);
                else drawNode(n);
            });

            view.setAttribute(
                'transform',
                `translate(${viewOffset.x},${viewOffset.y}) scale(${zoom})`
            );
        }

        function drawRoot(n) {
            const e = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
            e.setAttribute('cx', n.x);
            e.setAttribute('cy', n.y);
            e.setAttribute('rx', 70);
            e.setAttribute('ry', 45);
            e.setAttribute('fill', n.color);
            e.setAttribute('stroke', selectedNode === n.id ? '#1e293b' : 'white');
            e.setAttribute('stroke-width', selectedNode === n.id ? 3 : 2);
            e.style.cursor = 'pointer';
            e.style.filter = 'drop-shadow(0 2px 8px rgba(0, 0, 0, 0.15))';
            e.onmousedown = ev => startNodeDrag(ev, n);
            view.appendChild(e);

            const lines = wrapText(n.text, 10);
            lines.forEach((line, i) => {
                const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                t.setAttribute('x', n.x);
                t.setAttribute('y', n.y - (lines.length - 1) * 10 + i * 20);
                t.setAttribute('text-anchor', 'middle');
                t.setAttribute('dominant-baseline', 'middle');
                t.setAttribute('fill', 'white');
                t.setAttribute('font-size', '14');
                t.setAttribute('font-weight', 'bold');
                t.style.pointerEvents = 'none';
                t.textContent = line;
                view.appendChild(t);
            });
        }

        function drawNode(n) {
            const lines = wrapText(n.text, 12);
            const lineHeight = 20;
            const padding = 16;
            const height = lines.length * lineHeight + padding * 2;
            const width = 140;

            const r = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            r.setAttribute('x', n.x - width / 2);
            r.setAttribute('y', n.y - height / 2);
            r.setAttribute('width', width);
            r.setAttribute('height', height);
            r.setAttribute('rx', 8);
            r.setAttribute('fill', 'white');
            r.setAttribute('stroke', n.color);
            r.setAttribute('stroke-width', 2);
            r.style.cursor = 'pointer';
            r.style.filter = selectedNode === n.id
                ? 'drop-shadow(0 4px 12px rgba(0, 0, 0, 0.2))'
                : 'drop-shadow(0 2px 6px rgba(0, 0, 0, 0.1))';
            r.onmousedown = ev => startNodeDrag(ev, n);
            view.appendChild(r);

            lines.forEach((line, i) => {
                const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                t.setAttribute('x', n.x);
                t.setAttribute('y', n.y - (lines.length - 1) * lineHeight / 2 + i * lineHeight);
                t.setAttribute('text-anchor', 'middle');
                t.setAttribute('dominant-baseline', 'middle');
                t.setAttribute('fill', n.color);
                t.setAttribute('font-size', '14');
                t.setAttribute('font-weight', '500');
                t.style.pointerEvents = 'none';
                t.textContent = line;
                view.appendChild(t);
            });
        }

        function selectNode(id) {
            selectedNode = id;
            actions.style.display = 'flex';
            deleteBtn.style.display = id === 1 ? 'none' : 'inline-block';
            updateBreadcrumb();
            updateColumns();
            draw();
        }

        function saveData() {
            localStorage.setItem('mindmap-nodes', JSON.stringify(nodes));
        }

        function loadData() {
            const data = localStorage.getItem('mindmap-nodes');
            if (!data) return;

            try {
                nodes = JSON.parse(data);
                nextId = Math.max(...nodes.map(n => n.id)) + 1;
            } catch {
                // エラー時は何もしない
            }
        }

        function updateBreadcrumb() {
            breadcrumb.innerHTML = '';
            breadcrumb.style.display = 'block';

            let list = [];
            let cur = nodes.find(n => n.id === selectedNode);
            while (cur) {
                list.unshift(cur);
                cur = cur.parentId ? nodes.find(n => n.id === cur.parentId) : null;
            }

            list.forEach((n, i) => {
                const span = document.createElement('span');
                span.className = 'breadcrumb-item';
                span.textContent = n.text.length > 15 ? n.text.slice(0, 15) + '…' : n.text;
                span.onclick = () => selectNode(n.id);
                breadcrumb.appendChild(span);
                if (i < list.length - 1) {
                    breadcrumb.appendChild(document.createTextNode(' › '));
                }
            });
        }

        function getPath(nodeId) {
            const path = [];
            let cur = nodes.find(n => n.id === nodeId);
            while (cur) {
                path.unshift(cur);
                cur = cur.parentId ? nodes.find(n => n.id === cur.parentId) : null;
            }
            return path;
        }

        const columns = document.getElementById('columns');
        function updateColumns() {
            columns.innerHTML = '';

            if (!finderSelectedNode && !selectedNode) return;

            const baseNodeId = finderSelectedNode ?? selectedNode;
            const path = getPath(baseNodeId);

            for (let depth = 0; depth <= path.length; depth++) {
                const col = document.createElement('div');
                col.style.display = 'inline-block';
                col.style.verticalAlign = 'top';
                col.style.width = '220px';
                col.style.height = '100%';
                col.style.borderRight = '1px solid #e5e7eb';
                col.style.padding = '6px';
                col.style.boxSizing = 'border-box';

                let parentId;
                let highlightId = null;

                if (depth === 0) {
                    parentId = null;
                    highlightId = path[0]?.id;
                } else if (depth < path.length) {
                    parentId = path[depth - 1].id;
                    highlightId = path[depth]?.id;
                } else {
                    parentId = path[path.length - 1].id;
                    highlightId = null;
                }

                const list = nodes.filter(n => n.parentId === parentId);

                if (list.length === 0) {
                    const empty = document.createElement('div');
                    empty.textContent = '（子ノードなし）';
                    empty.style.color = '#9ca3af';
                    empty.style.fontSize = '13px';
                    empty.style.padding = '6px';
                    col.appendChild(empty);
                }

                list.forEach(n => {
                    const item = document.createElement('div');
                    item.className = 'column-item';
                    item.textContent = n.text;

                    if (n.id === highlightId || n.id === finderSelectedNode) {
                        item.classList.add('selected');
                    }

                    item.onclick = (e) => {
                        e.stopPropagation();
                        finderSelectedNode = n.id;
                        updateColumns();
                    };

                    col.appendChild(item);
                });

                columns.appendChild(col);
            }
        }

        function startNodeDrag(e, n) {
            e.stopPropagation();
            const rect = svg.getBoundingClientRect();
            const x = (e.clientX - rect.left - viewOffset.x) / zoom;
            const y = (e.clientY - rect.top - viewOffset.y) / zoom;
            draggingNode = n;
            dragOffset = { x: x - n.x, y: y - n.y };
            selectNode(n.id);
        }

        svg.onmousedown = e => {
            if (draggingNode) return;
            draggingCanvas = true;
            dragStart = { x: e.clientX - viewOffset.x, y: e.clientY - viewOffset.y };
        };

        window.onmousemove = e => {
            if (draggingNode) {
                const rect = svg.getBoundingClientRect();
                const x = (e.clientX - rect.left - viewOffset.x) / zoom;
                const y = (e.clientY - rect.top - viewOffset.y) / zoom;
                draggingNode.x = x - dragOffset.x;
                draggingNode.y = y - dragOffset.y;
                draw();
            } else if (draggingCanvas) {
                viewOffset.x = e.clientX - dragStart.x;
                viewOffset.y = e.clientY - dragStart.y;
                draw();
            }
        };

        window.onmouseup = () => {
            if (draggingNode) {
                saveData();
            }
            draggingNode = null;
            draggingCanvas = false;
        };

        function addChild() {
            const p = nodes.find(n => n.id === selectedNode);
            if (!p) return;
            const angle = Math.random() * Math.PI * 2;
            const d = 200;
            nodes.push({
                id: nextId++,
                text: '新しいノード',
                x: p.x + Math.cos(angle) * d,
                y: p.y + Math.sin(angle) * d,
                parentId: p.id,
                color: colors[Math.floor(Math.random() * colors.length)],
                isRoot: false
            });

            draw();
            saveData();
            updateColumns();
        }

        function startEdit() {
            const n = nodes.find(n => n.id === selectedNode);
            if (!n) return;
            const t = prompt('編集', n.text);
            if (t !== null && t.trim() !== '') {
                n.text = t;
                draw();
                updateBreadcrumb();
                updateColumns();
                saveData();
            }
        }

        function deleteNode() {
            function remove(id) {
                nodes.filter(n => n.parentId === id).forEach(c => remove(c.id));
                nodes = nodes.filter(n => n.id !== id);
            }
            if (selectedNode !== 1) {
                remove(selectedNode);
                selectedNode = null;
                actions.style.display = 'none';
                breadcrumb.style.display = 'none';
                draw();
                saveData();
                updateColumns();
            }
        }

        function zoomIn() { zoom = Math.min(zoom * 1.2, 3); draw(); }
        function zoomOut() { zoom = Math.max(zoom * 0.8, 0.3); draw(); }
        function resetView() { zoom = 1; viewOffset = { x: 0, y: 0 }; draw(); }

        const finderOverlay = document.getElementById('finderOverlay');

        function toggleFinder() {
            finderOverlay.classList.toggle('show');

            if (finderOverlay.classList.contains('show')) {
                finderSelectedNode = selectedNode;
                updateColumns();
            }
        }

        window.addEventListener('keydown', e => {
            if (e.key === 'Escape' && finderOverlay.classList.contains('show')) {
                toggleFinder();
            }
        });

        window.addEventListener('keydown', (e) => {
            if (e.key !== 'Enter') return;
            if (!finderOverlay.classList.contains('show')) return;
            if (!finderSelectedNode) return;

            selectNode(finderSelectedNode);
            const node = nodes.find(n => n.id === finderSelectedNode);
            if (node) teleportToNode(node);
            toggleFinder();
        });

        function teleportToNode(node) {
            const cx = window.innerWidth / 2;
            const cy = window.innerHeight / 2;

            viewOffset.x = cx - node.x * zoom;
            viewOffset.y = cy - node.y * zoom;

            draw();
        }

        function exportData() {
            // 1. nodes配列をJSON文字列に変換
            const json = JSON.stringify(nodes, null, 2);

            // 2. Blobオブジェクトを作成（JSONファイルとして）
            const blob = new Blob([json], { type: 'application/json' });

            // 3. ダウンロード用のURLを生成
            const url = URL.createObjectURL(blob);

            // 4. 非表示のaタグを作成してクリック
            const a = document.createElement('a');
            a.href = url;
            a.download = 'mindmap-' + Date.now() + '.json';  // ファイル名
            a.click();

            // 5. URLを解放（メモリリーク防止）
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            // 1. ファイルを取得
            const file = event.target.files[0];
            if (!file) return;

            // 2. FileReaderでファイルを読み込み
            const reader = new FileReader();

            reader.onload = function (e) {
                try {
                    // 3. JSON文字列をパース
                    const importedNodes = JSON.parse(e.target.result);

                    // 4. データの検証（最低限のチェック）
                    if (!Array.isArray(importedNodes)) {
                        alert('無効なファイル形式です');
                        return;
                    }

                    // 5. データを適用
                    nodes = importedNodes;

                    // 6. nextIdを更新（重要！）
                    nextId = Math.max(...nodes.map(n => n.id)) + 1;

                    // 7. 選択をリセット
                    selectedNode = 1;

                    // 8. 画面を再描画
                    draw();

                    // 9. LocalStorageにも保存
                    saveData();

                    alert('インポートが完了しました');

                } catch (error) {
                    alert('ファイルの読み込みに失敗しました: ' + error.message);
                }

                // 10. inputをリセット（同じファイルを再選択できるように）
                event.target.value = '';
            };

            // 11. ファイルをテキストとして読み込み開始
            reader.readAsText(file);
        }

        // 初期化
        loadData();
        selectedNode = 1;
        draw();
    </script>
</body>

</html>